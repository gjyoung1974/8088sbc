;Compile command line
;nasm bios.asm -o bios.bin

[BITS 16]
CPU 8086
ORG 0X0000

DATA_AREA:
TIMES 0X100 DB 0x00 ;I/O DATA AREA 

START:
	MOV AX, CS		;SETS STACK SEGMENT TO 0xF000
	MOV SS, AX		;
	MOV SP, 0XFFE0	;0xF000:0XFFE0 = 0XFFFE0
	
	CALL CLEAR_INT_VECTOR_TABLE	;THIS IS NOT NEEDED. BUT IT PUTS ALL ZERO IN INT VECTOR TABLE
								;THIS CAN BE HELPFUL TO SEE WHAT DOS INSTALLS
	CALL LOAD_INT_VECTOR_TABLE	;COPIES INTERRUPT VECTOR TABLE TO ADDRESS 0X0000:0X0000
	CALL LOAD_BIOS_DATA_AREA	;COPIES BIOS DATA TO ADDRESS 0X0000:0X0400
	CALL CLEAR_SCREEN			;CLEARS SCREEN
	CALL MESSAGE_1				;DISPLAYS BIOS MESSAGE
		
	MOV AX, CS		;SET SEGMENT REGISTERS TO CS
	MOV DS, AX		;
	MOV ES, AX		;

    JMP BOOT_DRIVE	;ADD TEST CODE HERE WITH OUT BOOTING DISK

BOOT_DRIVE:		
	MOV AX, 0X07C0 	;0X07C0:0X0000
	MOV ES, AX		;ES:BX = ADDRESS BUFFER
	MOV AX, 0X0201	;READ ONE SECTOR
	MOV BX, 0X0000	;ES:BX = ADDRESS BUFFER
	MOV CX, 0X0001	;1 SECTOR
	MOV DX, 0X0000	;DRIVE TO BOOT UP 0=A, 80=C
	INT 0X13		;INT 13
	MOV AX, 0X07C0	;SEGMENT
	MOV DS, AX		;SET DS
	MOV ES, AX		;SET ES
	MOV AX, 0X0000	;ZERO AX
	MOV BX, 0X0000	;ZERO BX
	MOV CX, 0X0000	;ZERO CX
	MOV DX, 0X0000	;ZERO DX
	JMP 0X07C0:0X0000	;JMP FAR 0X07C0:0X0000

CLEAR_INT_VECTOR_TABLE:
	MOV AX, 0X0000
	MOV DS, AX
	MOV BX, 0X0000
	MOV CX, 0X0400 
	MOV AX, 0X0000
  .LOOP_CLVT:
	MOV BYTE [BX], AL
	ADD BX, 0X0001
	LOOP .LOOP_CLVT
	RET	
	
LOAD_INT_VECTOR_TABLE:
	CLD
	MOV AX, 0X0000
	MOV ES, AX
	MOV DI, 0X0000
	MOV AX, CS
	MOV DS, AX
	MOV SI, INT_VECTOR_TABLE
	MOV CX, INT_VECTOR_TABLE.END - INT_VECTOR_TABLE
	REP MOVSB
	RET

LOAD_BIOS_DATA_AREA:
	MOV AX, 0X0040
	MOV ES, AX
	MOV DI, 0X0000
	MOV AX, CS
	MOV DS, AX
	MOV SI, BIOS_DATA_AREA
	MOV CX, BIOS_DATA_AREA.END - BIOS_DATA_AREA
	REP MOVSB
	RET
	
MESSAGE_1:
	MOV AX, CS
	MOV DS, AX
	MOV AH, 0X0E
	MOV CX, .END - .MESSAGE
	MOV BX, .MESSAGE	
	.LOOP:
	MOV AL, [BX]
	INT 0X10
	INC BX
	LOOP .LOOP
	RET
	.MESSAGE:
	DB 'BIOS 1.1 developed by Elijah Miller 2020', 0X0D, 0X0A
	DB 'BIOS 1.x hacked on by Gordon Young 2021', 0X0D, 0X0A
	DB '8088/V20 CPU, 1MB RAM', 0X0D, 0X0A
	DB 'Bios loaded at 0xF000:0x0000', 0X0D, 0X0A, 0X0A
	.END:
	
CLEAR_SCREEN:
	MOV AX, 0XB800
	MOV DS, AX
	MOV BX, 0X0000
	MOV CX, 2080 	;YES NOT HEX
	MOV AX, 0X0700
  .LOOP_CLS:
	MOV WORD [BX], AX
	ADD BX, 0X0002
	LOOP .LOOP_CLS
	RET

BIOS_DATA_AREA:
	;0x0400 (4 words)	IO ports for COM1-COM4 serial (each address is 1 word, zero if none)
	DW 0X0000
	DW 0X0000
	DW 0X0000
	DW 0X0000
	;0x0408 (4 words)	IO ports for LPT1-LPT4 parallel (each address is 1 word, zero if none)
	DW 0X0000
	DW 0X0000
	DW 0X0000
	DW 0X0000	;!!
	;0x0410 (word)		(Equip Flag) packed bit flags for detected hardware
	;look up number google, right now one floppy drive, 80x25 color, no coprocessor
	DW 0X02D
	;0x0412	 (byte)		MFG test
	DB 0x01
	;0x0413 (word)		Memory Size
	DW 0x0280			;280 640K, 
	;0x0415 (word)		IO Ram Size
	DW 0x0000
	;0x0417 (byte)		keyboard state flag 0
	DB 0X00
	;0x0418 (byte)		keyboard state flag 1
	DB 0X00	
	;0x0419 (byte)		ALT_INPUT
	DB 0X00	
	;0x041A (word) 		keyboard head 
	DW 0x001E
	;0x041C (word)		keyboard tail
	DW 0x001E 
	;0x041E (32 bytes)	keyboard buffer
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	;0x043E 		DISKETTE DATA AREAS
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00
	;0x0449 (byte)		Display Mode [VIDEO DISPLAY DATA AREA]
	DB 0X03				;80x25  8x8   640x200   16 Colors 0xB800 CGA
	;0x044A (word)		number of columns in text mode
	DW 0X0050
	;0X044C (word)
	DW 0X0000
	;0X044E (word)
	DW 0X0000	
	;0X0450 (16 BYTE AS WORD)	:CURSOR_POSN 8 PAGES   col, row
	DW 0X0000, 0X0000
	DW 0X0000, 0X0000
	DW 0X0000, 0X0000
	DW 0X0000, 0X0000
	;0X0460 (word)		Cursor Mode
	DW 0X0000
	;0x0462			Active Page
	DB 0X00
	;0x0463 (2 bytes, taken as a word)	base IO port for video
	DB 0X00
	DB 0X00
	;0x0465	(byte)
	DB 0x00
	;0x0466	(byte)
	DB 0x00
	;0x0467	(word)
	DW 0x0000
	;0x0469	(word)
	DW 0x0000
	;0x046B	(byte)
	DB 0x00
	;0x046C (word)		# of IRQ0 timer ticks since boot
	DW 0X0000
	
	;LATER 0x046E
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00
	;
	
	;0x0475 (byte)		# of hard disk drives detected
	DB 0X00
	
	;LATER 0x0476
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00
	;
	
	;0x0480 (word)		keyboard buffer start
	DW 0X001E
	;0x0482 (word)		keyboard buffer end
	DW 0X003E
	
	;LATER 0x0484
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00, 0X00
	DB 0X00, 0X00, 0X00
	
	;0x0497 (byte)		last keyboard LED/Shift key state
	DB 0X00	

.END:
INT_VECTOR_TABLE:
	DW INT00, 0xF000
	DW INT01, 0xF000
	DW INT02, 0xF000
	DW INT03, 0xF000
	DW INT04, 0xF000
	DW INT05, 0xF000
	DW INT06, 0xF000
	DW INT07, 0xF000
	DW INT08, 0xF000
	DW INT09, 0xF000
	DW INT0A, 0xF000
	DW INT0B, 0xF000
	DW INT0C, 0xF000
	DW INT0D, 0xF000
	DW INT0E, 0xF000
	DW INT0F, 0xF000
	DW INT10, 0xF000
	DW INT11, 0xF000
	DW INT12, 0xF000
	DW INT13, 0xF000
	DW INT14, 0xF000
	DW INT15, 0xF000
	DW INT16, 0xF000
	DW INT17, 0xF000
	DW INT18, 0xF000
	DW INT19, 0xF000
	DW INT1A, 0xF000
	DW INT1B, 0xF000
	DW INT1C, 0xF000
	DW INT1D, 0xF000
	DW INT1E, 0xF000
	DW INT1F, 0xF000
   .END:

INT00: ;Divide by Zero
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT01: ;Single Step
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT02: ;Nonmaskable 
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '2'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT03: ;Breakpoint
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '3'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT04: ;Overflow
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '4'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT05: ;Print Screen
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '5'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT06: ;Reserved
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '6'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT07: ;Reserved
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '7'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT08: ;Reserved
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '8'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT09: ;Reserved
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '9'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPTM INTERRUPT
INT0A: ;Reserved
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'A'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT	
INT0B: ;Communications
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'B'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT		
INT0C: ;Communications
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'C'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT			
INT0D: ;Disk
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'D'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT0E: ;Diskette
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'E'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT0F: ;Printer
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '0'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'F'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT10:  ;Video
	;CLI
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH DI
	PUSH SI
	PUSH DS
	PUSH ES
	
	CMP AH, 0x0E               ;Check the AH to determine what function is being called.
	JZ .TELETYPE               ;Jump if 0x0E   

	JMP .END_INT10
		
   .TELETYPE: 	;0X0450
	PUSH AX
	MOV AX, 0X0040
	MOV DS, AX					;Set data segment
	MOV AH, 0X00				;ah=0
	MOV AL, BYTE [0X51]			;Current Row
	MOV CX, WORD [0x04A] 		;number of cols per row
	ADD CX, CX					;Double col for hidden char data
	MUL CL						;mul Current row * cols
	MOV BH, 0X00				;BH=0
	MOV BL, BYTE [0X50]			;Set current col
	ADD BX, BX					;Double col for hidden char data
	ADD BX, AX					;Add in row
	MOV AX, 0XB800				;
	MOV DS, AX					;Set video segment
	POP AX						;restore char	
	CMP AL, 0X0D				;Check for enter
	JZ .ENTER					;return carrage
	CMP AL, 0X0A				;Check for line feed
	JZ .LINE_FEED				;line feed
	CMP AL, 0X08				;check for back space
	JZ .BACKSPACE
	MOV [BX], AL				;Char out
	JMP .MOVE_CURSOR_FORWARD

 .MOVE_CURSOR_FORWARD:
	MOV AX, 0X0040				;Check col
	MOV DS, AX					;Set data segment	
	MOV BX, 0X0050				;Col
	MOV AH, 0X00				;AH=0
	MOV AL, BYTE [BX]			;get current col
	INC AL						;inc col
	CMP AX, WORD [0x04A] 		;number of cols per row
	JB .NOT_END_OF_COL
  .END_OF_COL:	
  	MOV AX, 0X0040				;Check col
	MOV DS, AX					;Set data segment	
  	MOV BX, 0X0050				;
	MOV AL, 0X00				;
	MOV BYTE [BX], AL			;Set col to 0
	MOV BX, 0X0051				;Row
	MOV AH, 0X00				;AH=0
	MOV AL, BYTE [BX]			;get current ROW
	INC AL						;inc row
	CMP AX, 0X19				;cmp to 25
	JB .NOT_END_OF_ROWS
  .SCROLL_UP:	
	CLD							;SCROLL UP
	MOV AX, 0XB800
	MOV ES, AX
	MOV DI, 0X0000
	MOV AX, 0XB800
	MOV DS, AX
	MOV SI, 0X00A0
	MOV CX, 4000
	REP MOVSB
	JMP .END_INT10
	
 .NOT_END_OF_ROWS:
	MOV BX, 0X0051				;ROW
	MOV BYTE [BX], AL			;STORE AL=ROW
	JMP .END_INT10				;END

.NOT_END_OF_COL:
	MOV BX, 0X0050				;Col
	MOV BYTE [BX], AL			;STORE AL=COL
	JMP .END_INT10				;END	

  .ENTER:
  	MOV AX, 0X0040				;Check col
	MOV DS, AX					;Set data segment	
  	MOV BX, 0X0050				;
	MOV AL, 0X00				;
	MOV BYTE [BX], AL			;Set col to 0
	JMP .END_INT10	
	
  .LINE_FEED:
  	MOV AX, 0X0040				;Check col
	MOV DS, AX					;Set data segment	
	MOV BX, 0X0051				;Row
	MOV AH, 0X00				;AH=0
	MOV AL, BYTE [BX]			;get current ROW
	INC AL						;inc row
	CMP AX, 0X19				;cmp to 25
	JB .NOT_END_OF_ROWS			;STORE AL IN ROW AND END
	JMP .SCROLL_UP				;SCROLL UP
	
  .BACKSPACE:	
    SUB BX, 0X0002				;GO BACK A SPACE IN RAM
    MOV BYTE [BX], 0X00			;Clear char
 	MOV AX, 0X0040				;Check col
	MOV DS, AX					;Set data segment	
	MOV BX, 0X0050				;Col
	MOV AH, 0X00				;AH=0
	MOV AL, BYTE [BX]			;get current col
	DEC AL						;
	CMP AX, WORD [0x04A] 		;number of cols per row
	JB .NOT_BEGIN_OF_COL
  .BEGIN_OF_COL:	
  	MOV AX, 0X0040				;Check col
	MOV DS, AX					;Set data segment	
  	MOV BX, 0X0050				;
	MOV AL, 0X4F				;
	MOV BYTE [BX], AL			;Set col to 49
	MOV BX, 0X0051				;Row
	MOV AH, 0X00				;AH=0
	MOV AL, BYTE [BX]			;get current ROW
	DEC AL						;dec row
	CMP AX, 0X19				;cmp to 25
	JB .NOT_END_OF_ROWS
  .BEGIN_OF_ROW:	
  	MOV BX, 0X0050				;col
	MOV BYTE [BX], 0X00
	MOV BX, 0X0051				;ROW
	MOV BYTE [BX], 0X00
	JMP .END_INT10
	
 .NOT_BEGIN_OF_ROW:
	MOV BX, 0X0051				;ROW
	MOV BYTE [BX], AL
	JMP .END_INT10

.NOT_BEGIN_OF_COL:
	MOV BX, 0X0050				;Col
	MOV BYTE [BX], AL
	JMP .END_INT10 
  
   .END_INT10:
    POP ES
	POP DS
	POP SI
	POP DI
	POP DX
	POP CX
	POP BX
	POP AX
	;STI
	IRET
INT11: ;Equipment Check	
	CLI							;CLEAR INTERRUPS FLAG
	PUSH DS						;STORE DS
	PUSH BX						;STORE BX
	MOV AX, 0X0040				;BIOS DATA AREA
	MOV DS, AX					;SET DATA SEGMENT
	MOV BX, 0X0010				;OFFSET 0X10 EQUIPMENT LIST
	MOV AX, WORD [BX]			;STORE EQUPMENT LIST AX
	POP BX						;RESTORE BX
	POP DS						;RESTORE DS
	STI							;SET INTERRUPS FLAG
	IRET						;RETRUN
INT12: ;Memory	
	CLI							;CLEAR INTERRUPS FLAG
	PUSH DS						;STORE DS
	PUSH BX						;STORE BX
	MOV AX, 0X0040				;BIOS DATA AREA
	MOV DS, AX					;SET DATA SEGMENT
	MOV BX, 0X0013				;OFFSET 0X13 FOR MEMORY SIZE
	MOV AX, WORD [BX]			;STORE MEMORY SIZE AX
	POP BX						;RESTORE BX
	POP DS						;RESTORE DS
	STI							;SET INTERRUPS FLAG
	IRET						;RETRUN
INT13: ;Diskette/Disk
;;;;;;JUMP TABLE;;;;;	
	;CLI
	CMP DL, 0X00
	JE .START_INT13
	
	;THESE 2 LINES OF CODE ENABLE THE HARD DRIVE!!!!
	;CMP DL, 0X80
	;JE .START_INT13
	
	JNE .NOT_A_DRIVE
	
  .START_INT13:	
	CMP AH, 0X00
	JE .RESET_DISK_SYSTEM ;GET STATUS OF LAST OPERATION
	CMP AH, 0X01
	JE .GET_STATUS_LAST_OPERATION
	CMP AH, 0X02
	JE .READ_WRITE_DISK
	CMP AH, 0X03
	JE .READ_WRITE_DISK
	CMP AH, 0X08
	JE .PARAMETERS
	CMP AH, 0X15
	JE .GET_DISK_TYPE
	
	PUSH AX
	MOV AH, 0X0E
	MOV AL, 'I'
	INT 0X10
	MOV AL, '1'
	INT 0X10
	MOV AL, '3'	
	INT 0X10
	POP AX
	CALL DUMP_REGISTERS	
	HLT
	
  .NOT_A_DRIVE:
	MOV AH, 0X01	;STATUS 0X00 SUCCESSFULL
	STC				;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG
;;;;;;RESET;;;;;;	
  .RESET_DISK_SYSTEM:	
	MOV AH, 0X00	;STATUS 0X00 SUCCESSFULL
	CLC				;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG

;;;;;;GET STATUS OF LAST OPERATION;;;;;
  .GET_STATUS_LAST_OPERATION:
  	MOV AH, 0X00	;STATUS 0X00 SUCCESSFULL
	CLC				;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG

;;;;;;READ AND WRITE;;;;;;
  .READ_WRITE_DISK:
  	
	PUSH DS
	PUSH ES
	PUSH DX
	PUSH CX
	PUSH BX
	PUSH AX
	PUSH AX	
	
	MOV [CS:0X0001], AL	;NUMBER OF SECTORS
	MOV AL, CH		
	MOV [CS:0X0002], AL	;CYLINDER 0-7
	PUSH CX
	MOV CH, CL
	MOV CL, 0X06
	SHR CH, CL
	AND CH, 0X03
	MOV AL, CH	
	MOV [CS:0X0003], AL	;CYLINDER 8-9
	POP CX
	AND CL, 0X3F
	MOV AL, CL		
	MOV [CS:0X0004], AL	;SECTOR
	MOV AL, DH
	MOV [CS:0X0005], AL	;HEAD
	MOV AL, DL
	MOV [CS:0X0006], AL	;DRIVE	
	MOV AX, BX
	MOV [CS:0X0007], AX	;BX
	MOV AX, ES
	MOV [CS:0X0009], AX	;ES
	
	POP AX
	MOV AL, AH								;AH IS THE COMMAND VALUE
	MOV [CS:0x0000], AL				;INT13 COMMAND BYTE 0xF000:0X0000
  .READ_DISK_WAIT:							;WAIT FOR RASPBERRY PI LOOP
	MOV AL, [CS:0x0000]
	CMP AL, 0XFF							;CHECK TO SEE IF RASPBERRY PI IS DONE		
	JNE .READ_DISK_WAIT						;LOOP UNTIL COMPLETE

	POP AX			;AL NEED TO RETURN NUMBER OF SECTORS
	POP BX			;RESTORE BX
	POP CX			;RESTORE CX
	POP DX			;RESTORE DX
	POP ES			;RESTORE ES
	POP DS			;RESTORE DS
	MOV AH, 0X00	;STATUS 0X00 SUCCESSFULL
	CLC				;CLEAR CARRY FLAG SUCCESFUL	
	JMP .INT13_END_WITH_CARRY_FLAG
;;;;;;PARAMETERS;;;;;;	
  .PARAMETERS:		;0x08 RETRUNS DISK PARAMETERS  
	CMP DL, 0X80
	JE .HARD_DRIVE_PARAMETERS
	PUSH DS							;STORE DS
  	PUSH AX							;STORE AX
	MOV AX, CS						;GET CODE SEGMENT
	MOV DS, AX						;SET DATA SEGMENT TO CS
	MOV ES, AX						;FOR DRIVE PARAMETER TABLE ES:DI
	POP AX  
	
	MOV AL, DL						;SEND DRIVE NUMBER TO RASPBERRY PI 
	MOV [CS:0X0006], AL					;DRIVE	
	
	MOV AL, AH			 			;AH IS THE COMMAND VALUE
	MOV [CS:0x0000], AL				;INT13 COMMAND BYTE 0xF000:0X0000
  .PARAMETERS_WAIT:					;WAIT FOR RASPBERRY PI LOOP
	MOV AL, [CS:0x0000]
	CMP AL, 0XFF					;CHECK TO SEE IF RASPBERRY PI IS DONE		
	JNE .PARAMETERS_WAIT			;LOOP UNTIL COMPLETE
	
	MOV AL, [CS:0X000B]									;DRIVE TYPE/MEDIA DESCRIPTOR 
	MOV BL, AL									;BL RETURNS DRIVE TYPE
	MOV AL, [CS:0X0011]									;LOW 8 BITS CYLINDER
	MOV CH, AL									;CH RETURNS LOW 8 BITS CYLINDER	
	MOV AL, [CS:0X0010]									;SECTORS PER TRACK AND 2 HIGH BITS OF CYLINDER
	MOV CL, AL									;CL RETURNS SECTORS PER TRACK AND 2 HIGH BITS OF CYLINDER
	MOV AL, [CS:0X000C]									;NUMBER OF HEADS/CLYINDER
	DEC AL										;STARTS AT 0
	MOV DH, AL									;DL RETURNS HEADS/CLYINDER	
	MOV DL, 0X01 								;NUMBER OF DRIVES
	MOV AL, [CS:0X0010]									;SECTORS PER TRACK AND 2 HIGH BITS OF CYLINDER
	AND AL, 0X3F								;REMOVE CYLINDER BITS
	DEC AL										;REDUCE BY ONE
	MOV BYTE [.DISK_PARAMETER_TABLE + 4], AL	;FOR FLOPPY DRIVES DISK PARAMETER TABLE	
	MOV AL, [CS:0X000F]									;BYTES PER SECTOR HIGH SIDE
	MOV BYTE [.DISK_PARAMETER_TABLE + 3], AL	;FOR FLOPPY DRIVES DISK PARAMETER TABLE
	MOV DI, INT13.DISK_PARAMETER_TABLE			;FOR DRIVE PARAMETER TABLE ES:DI

	POP DS							;RESTORE DS
	MOV AL, 0X00 					;ON SOME BIOS RETRUN ZERO
	MOV AH, 0X00					;STATUS 0X00 SUCCESSFULL 
	CLC								;CLEAR CARRY FLAG SUCCESFUL	
    JMP .INT13_END_WITH_CARRY_FLAG
	
  .DISK_PARAMETER_TABLE:
	DB 0X00							;00   specify byte 1; step-rate time, head unload time
	DB 0X00							;01   specify byte 2; head load time, DMA mode
	DB 0X00							;02   timer ticks to wait before disk motor shutoff
	DB 0X00							;03   bytes per sector code:
									;0 - 128 bytes	2 - 512 bytes
									;1 - 256 bytes	3 - 1024 bytes
	DB 0X00							;04   sectors per track (last sector number)
	DB 0X00							;05   inter-block gap length/gap between sectors
	DB 0X00							;06   data length, if sector length not specified
	DB 0X00							;07   gap length between sectors for format
	DB 0X00							;08   fill byte for formatted sectors
	DB 0X00							;09   head settle time in milliseconds
	DB 0X00							;0A   motor startup time in eighths of a second	
;;;;;;HARD DRIVE PARAMETERS;;;;;;		
.HARD_DRIVE_PARAMETERS:
	MOV AL, DL						;SEND DRIVE NUMBER TO RASPBERRY PI
	MOV [CS:0X0006], AL					;DRIVE	
	MOV AL, AH			 			;AH IS THE COMMAND VALUE
	MOV [CS:0x0000], AL				;INT13 COMMAND BYTE 0xF000:0X0000
  .HARD_DRIVE_PARAMETERS_WAIT:			;WAIT FOR RASPBERRY PI LOOP
	MOV AL, [CS:0x0000]
	CMP AL, 0XFF					;CHECK TO SEE IF RASPBERRY PI IS DONE		
	JNE .HARD_DRIVE_PARAMETERS_WAIT	;LOOP UNTIL COMPLETE
	MOV AL, [CS:0X0011]						;LOW 8 BITS CYLINDER
	MOV CH, AL						;CH RETURNS LOW 8 BITS CYLINDER	
	MOV AL, [CS:0X0010]						;SECTORS PER TRACK AND 2 HIGH BITS OF CYLINDER
	MOV CL, AL						;CL RETURNS SECTORS PER TRACK AND 2 HIGH BITS OF CYLINDER
	MOV AL, [CS:0X000C]						;NUMBER OF HEADS/CLYINDER
	DEC AL							;STARTS AT 0
	MOV DH, AL						;DL RETURNS HEADS/CLYINDER	
	MOV DL, 0X01 					;NUMBER OF DRIVES
	MOV AL, 0X00 					;ON SOME BIOS RETRUN ZERO
	MOV AH, 0X00					;STATUS 0X00 SUCCESSFULL 
	CLC								;CLEAR CARRY FLAG SUCCESFUL	
    JMP .INT13_END_WITH_CARRY_FLAG
;;;;;;GET_DISK_TYPE;;;;;;
  .GET_DISK_TYPE:
	MOV AL, DL						;SEND DRIVE NUMBER TO RASPBERRY PI 
	MOV [CS:0X0006], AL					;DRIVE	
	MOV AL, AH			 			;AH IS THE COMMAND VALUE
	MOV [CS:0x0000], AL				;INT13 COMMAND BYTE 0xF000:0X0000
  .GET_DISK_TYPE_WAIT:				;WAIT FOR RASPBERRY PI LOOP
	MOV AL, [CS:0x0000]
	CMP AL, 0XFF					;CHECK TO SEE IF RASPBERRY PI IS DONE		
	JNE .GET_DISK_TYPE_WAIT			;LOOP UNTIL COMPLETE
	MOV AL, [CS:0X0012]	
	MOV DL, AL
	MOV AL, [CS:0X0013]
	MOV DL, AL
	MOV AL, [CS:0X0014]
	MOV DL, AL
	MOV AL, [CS:0X0015]
	MOV DL, AL
	MOV AL, [CS:0X0016]
	MOV AH, AL
	MOV AL, 0X00					;JUST BECUASE
	CLC								;CLEAR CARRY FLAG SUCCESFUL
	JMP .INT13_END_WITH_CARRY_FLAG
;;;;;;END;;;;;;;;		
  .INT13_END_WITH_CARRY_FLAG:	;THIS IS HOW I RETURN THE CARRY FLAG
	PUSH AX						;STORE AX
	PUSHF						;STORE FLAGS
	POP AX						;GET AX = FLAGS
	PUSH BP						;STORE BP
	MOV BP, SP              	;Copy SP to BP for use as index
	ADD BP, 0X08				;offset 8
	AND WORD [BP], 0XFFFE		;CLEAR CF = ZER0
	AND AX, 0X0001				;ONLY CF 
	OR	WORD [BP], AX			;SET CF AX
	POP BP               		;RESTORE BASE POINTER
	POP AX						;RESTORE AX	
	;STI							;SET INTERRUPS FLAG
	IRET						;RETRUN
	
INT14: ;Communications
	IRET
INT15: ;Cassette
	CLI							;CLEAR INTERRUPT FLAG
	MOV AL, 0X00				;AL = 0X00
	MOV AH, 0X86				;NO CASSETTE PRESENT
	STC							;NOT BIOS SUPPORTED
								;THIS IS HOW I RETURN THE CARRY FLAG
	PUSH AX						;STORE AX
	PUSHF						;STORE FLAGS
	POP AX						;GET AX = FLAGS
	PUSH BP						;STORE BP
	MOV BP, SP              	;Copy SP to BP for use as index
	ADD BP, 0X08				;offset 8
	AND WORD [BP], 0XFFFE		;CLEAR CF = ZER0
	AND AX, 0X0001				;ONLY CF 
	OR	WORD [BP], AX			;SET CF AX
	POP BP               		;RESTORE BASE POINTER
	POP AX						;RESTORE AX	
	STI							;SET INTERRUPS FLAG
	IRET						;RETRUN		
INT16: ;Keyboard
  	CMP AH, 0X00			;Check ah 
	JZ .WAIT_FOR_KEY		;ah=0
	CMP AH, 0X01					
	JZ .CHECK_ZERO_FLAG		;ah=1
	CMP AH, 0X02					
	JZ .GET_SHIFT_FLAGS		;ah=2
	IRET

  .WAIT_FOR_KEY:
	PUSH BX
	PUSH DS
  .WAIT_FOR_KEY_LOOP:
	STI
	MOV AX, 0X0040
	MOV DS, AX
	CLI
	MOV BX, [0X001A]		;Tail
	CMP BX, [0X001C]		;Head
	JZ .WAIT_FOR_KEY_LOOP
	MOV AX, [BX]
	ADD BX, 0X0002			;Mov bx forward through buffer
	CMP BX, [0X0082]		;Check to see if at the end
	JB .NOT_END_OF_BUFFER	;Jump oveR next step if not at the end
	MOV BX, [0X0080]		;Set bx back to begining 
	.NOT_END_OF_BUFFER:
	MOV [0X001A], BX	
	POP DS
	POP BX
	STI
	IRET

  .CHECK_ZERO_FLAG:	
  	PUSH BX				
	PUSH DS
	MOV AX, 0X0040
	MOV DS, AX

	MOV BX, [0X001A]		;Tail
	CMP BX, [0X001C]		;Head
	MOV AX, [BX]
	POP DS
	POP BX
	
	PUSH AX						;STORE AX
	PUSHF						;STORE FLAGES
	POP AX						;AX = FLAGS
    PUSH BP						;STORE BP
	MOV BP, SP              	;Copy SP to BP for use as index
	ADD BP, 0X08				;offset 8
	AND WORD [BP], 0XFFBF		;CLEAR ZF
	AND AX, 0X0040				;ONLY ZF
	OR	WORD [BP], AX			;SET ZF
	POP BP               		;RESTORE BASE POINTER
	POP AX						;RESTORE AX
	
	IRET
	
  .GET_SHIFT_FLAGS:	  
	MOV AX, 0X0000				;FOR NOW RETURNS NOTHING. 
	IRET
	
INT17: ;Printer	
	IRET
INT18: ;Resident Basic
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '8'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT19: ;Bootstrap
	JMP 0XFFFF:0X0000	;JUMPS TO BOOT CODE
INT1A: ;Time of Day
	;CLI
	PUSH DS
  	PUSH BX
	MOV AX, 0X0040		;BIOS DATA AREA
	MOV DS, AX			;SET DS
	MOV BX, 0X006C		;NUMBER OF CLICKS
	MOV DX, WORD [BX]	;SET DX CLICKS
	MOV CX, 0X0000		;ZERO FOR NOW
	MOV AX, 0X0000		;
	POP BX
	POP DS
	;STI
	IRET
INT1B: ;Keyboard Break
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'B'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT1C: ;Timer Tick
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'C'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT1D: ;Video Initialization 
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'D'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT1E: ;Diskette Parameters
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'E'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
INT1F: ;Video Graphics Characters
	MOV AH, 0X0E	;SET AH 0X0E FOR TELOTYPE
	MOV AL, 'I'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, '1'		;SET AL TO CHAR	
	INT 0X10		;CALL INTERRUPT 0X10
	MOV AL, 'F'		;SET AL TO CHAR
	INT 0X10		;CALL INTERRUPT 0X10
	HLT				;HLT PROCESSOR NOT SUPPORTED INTERRUPT
	IRET			;RETURN FROM INTERRUPT
	
DUMP_REGISTERS:	
	PUSH AX
	PUSH DX
	PUSH CX
	PUSH BX
	PUSH AX	
	
	MOV AH, 0X0E
	MOV AL, ' '
	INT 0X10
	MOV AL, 'A'
	INT 0X10
	MOV AL, 'X'	
	INT 0X10
	MOV AL, '='
	INT 0X10	
	POP AX
	PUSH AX
	MOV AL, AH
	CALL WIRTE_AL_INT10_E
	POP AX
	CALL WIRTE_AL_INT10_E
	
	MOV AH, 0X0E
	MOV AL, ' '
	INT 0X10
	MOV AL, 'B'
	INT 0X10
	MOV AL, 'X'	
	INT 0X10
	MOV AL, '='
	INT 0X10	
	POP AX
	PUSH AX
	MOV AL, AH
	CALL WIRTE_AL_INT10_E
	POP AX
	CALL WIRTE_AL_INT10_E
	
	MOV AH, 0X0E
	MOV AL, ' '
	INT 0X10
	MOV AL, 'C'
	INT 0X10
	MOV AL, 'X'	
	INT 0X10
	MOV AL, '='
	INT 0X10	
	POP AX
	PUSH AX
	MOV AL, AH
	CALL WIRTE_AL_INT10_E
	POP AX
	CALL WIRTE_AL_INT10_E
	
	MOV AH, 0X0E
	MOV AL, ' '
	INT 0X10
	MOV AL, 'D'
	INT 0X10
	MOV AL, 'X'	
	INT 0X10
	MOV AL, '='
	INT 0X10	
	POP AX
	PUSH AX
	MOV AL, AH
	CALL WIRTE_AL_INT10_E
	POP AX
	CALL WIRTE_AL_INT10_E
	
	MOV AH, 0X0E
	MOV AL, 0X0D
	INT 0X10
	
	POP AX
	RET
;;;;;;;;;;;;;;;;;;;;;;;
;WRITE TO SCREEN;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;
WIRTE_AL_INT10_E:

	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX

	MOV BL, AL

	MOV DH, AL
	MOV CL, 0X04
	SHR DH, CL

	MOV AL, DH
	AND AL, 0X0F
	CMP AL, 0X09
	JA LETTER_HIGH

	ADD AL, 0X30
	JMP PRINT_VALUE_HIGH

	LETTER_HIGH:
	ADD AL, 0X37

	PRINT_VALUE_HIGH:
	MOV AH, 0X0E
	INT 0X10

	MOV AL, BL
	AND AL, 0X0F
	CMP AL, 0X09
	JA LETTER_LOW

	ADD AL, 0X30
	JMP PRINT_VALUE_LOW

	LETTER_LOW:
	ADD AL, 0X37

	PRINT_VALUE_LOW:
	MOV AH, 0X0E
	INT 0X10

	POP DX
	POP CX
	POP BX
	POP AX

	RET

	
DB 'END OF BIOS FILE'
